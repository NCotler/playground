<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>GridMove</title>
    <style>

      div#TextDiv {
        vertical-align: top;
      }

    </style>
</head>

<body>
  <div style="display: inline-block">
    <canvas id="myCanvas" width="600" height="600" style="border:10px solid #000000;"></canvas>
  </div>
  <div style="display: inline-block" id="TextDiv">
        <p>Use arrow keys to move.</p> 
        <p>Move to the green tile.</p>
        <p id="Points"></p>
        <p id="Gold"></p>
      </div>
</body>
<script>

//TODO: convert all == to ===
//be consistent about x vs X (x is paramenter and temp while X is property of object)

    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");

    var width = c.width;
    var height = c.height;
  
    var numberOfTilesX_axis = 10;
    var numberOfTilesY_axis = numberOfTilesX_axis;

//distance calculation
    var centerOfTileToSideOfTile = (width/(numberOfTilesX_axis*2));
    var centerOfTileToTopOfTile = (width/(numberOfTilesX_axis*2));

//pixel location finder
    var tileToPixelCenter = [];

//game data
    var points = 0;
    var gold = 0;
    var enemyIDtracker = 0;
    var enemyArr = [];
    var goldIDtracker = 0;
    var goldArr = [];


function drawTileGrid()
{
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#000000';
      for (var i = 1; i < numberOfTilesX_axis; i++) {
        ctx.beginPath();
        ctx.moveTo(i * (centerOfTileToSideOfTile*2), 0);
        ctx.lineTo(i * (centerOfTileToSideOfTile*2), height);
        ctx.stroke();
    }

    for (var i = 1; i < numberOfTilesY_axis; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * (centerOfTileToTopOfTile*2));
        ctx.lineTo(width, i * (centerOfTileToTopOfTile*2));
        ctx.stroke();
    }
}

//create array for getting pixel center points of tiles
//e.g. tileToPixelCenter[2] is center of 2nd tile
(function getPixelCenterPointsOfTiles()
{
      for(var i = 1; i <= numberOfTilesY_axis; i++)
    {
        tileToPixelCenter.push((i*(width/(numberOfTilesX_axis)))-(width/(numberOfTilesX_axis*2)));
    }
})();


        var player = {
      radius: (centerOfTileToSideOfTile) - (width/120),
      //X, Y, destX, and destY are tile positions; not pixel positions
      X: 0,
      Y: 0,
      destX: 0,
      destY: 0,
      pixelX: tileToPixelCenter[0],
      pixelY: tileToPixelCenter[0],
    };

    var goalTile = {
      X: numberOfTilesX_axis-1,
      Y: numberOfTilesY_axis-1,
    }

    //constructor for Enemy piece
    function Enemy(x, y, id)
    {
      this.ID = id;
      this.X = x;
      this.Y = y;
      this.destX = x;
      this.destY = y;
      this.pixelX = tileToPixelCenter[x];
      this.pixelY = tileToPixelCenter[y];
      this.radius = (centerOfTileToSideOfTile) - (width/120);

      this.drawEnemy = function()
      {
        //create generalized function for drawing player and enemys
        //x and y are pixels and not tiles
        ctx.beginPath();
        ctx.arc(this.pixelX, this.pixelY, this.radius, 0, 2 * Math.PI, false);
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.lineWidth = 5;
        ctx.strokeStyle = 'gray';
        ctx.stroke();
      }

      this.moveEnemy = function()
      {
        var possibleMoves = [];
        //check left
        if(checkIfTileHasPieceOnIt(this.X-1, this.Y) && this.X-1 >= 0)
        {
          possibleMoves.push({X:this.X-1, Y:this.Y, whichWay: "left"});
        }
        //check right
        if(checkIfTileHasPieceOnIt(this.X+1, this.Y) && this.X+1 <= numberOfTilesX_axis-1)
        {
          possibleMoves.push({X:this.X+1, Y:this.Y, whichWay: "right"});
        }
        //check above
        if(checkIfTileHasPieceOnIt(this.X, this.Y-1) && this.Y-1 >= 0)
        {
          possibleMoves.push({X:this.X, Y:this.Y-1, whichWay: "above"});
        }
        //check below
        if(checkIfTileHasPieceOnIt(this.X, this.Y+1) && this.Y+1 <= numberOfTilesY_axis-1)
        {
          possibleMoves.push({X:this.X, Y:this.Y+1, whichWay: "below"});
        }

        if(possibleMoves.length > 0)
        {
          let rand = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
          this.pixelX = tileToPixelCenter[this.X];
          this.pixelY = tileToPixelCenter[this.Y];
          this.X = rand.X;
          this.Y = rand.Y;
          this.destX = rand.X;
          this.destY = rand.Y;
        }
      }
    }

    function Gold(x,y,id)
    {
      this.ID = id;
      this.X = x;
      this.Y = y;
      this.radius = (centerOfTileToSideOfTile) - (width/120);

      this.drawGold = function()
      {
        //create generalized function for drawing player and enemys
        //x and y are pixels and not tiles
        ctx.beginPath();
        ctx.arc(tileToPixelCenter[this.X], tileToPixelCenter[this.Y], this.radius, 0, 2 * Math.PI, false);
        ctx.fillStyle = 'yellow';
        ctx.fill();
        ctx.lineWidth = 5;
        ctx.strokeStyle = 'blue';
        ctx.stroke();
      }

    }
  
      function drawPlayer(x,y)
      {
        //create generalized function for drawing player and enemys
        //x and y are pixels and not tiles
      ctx.beginPath();
      ctx.arc(x,y, player.radius, 0, 2 * Math.PI, false);
      ctx.fillStyle = '#BADA55';
      ctx.fill();
      ctx.lineWidth = 5;
      ctx.strokeStyle = '#B000B5';
      ctx.stroke();
      }

    function drawGoalTile(X,Y)
    {
      //use this funct? colorTile(x,y,"blue");
      ctx.beginPath();
      ctx.lineWidth=2;
      ctx.strokeStyle='#11DAFF';
      ctx.fillStyle = "green";
      ctx.rect(tileToPixelCenter[X]-centerOfTileToSideOfTile,tileToPixelCenter[Y]-centerOfTileToTopOfTile,centerOfTileToSideOfTile*2,centerOfTileToTopOfTile*2); 
      ctx.fill();
      ctx.stroke();
    }

      function checkForGoal()
      {
        if(player.X == goalTile.X && player.Y == goalTile.Y)
        {
          points += 1;
          let myArray = findAllOpenTiles();
          let rand = myArray[Math.floor(Math.random() * myArray.length)];
          enemyArr.push(new Enemy(rand.X, rand.Y, enemyIDtracker));
          enemyIDtracker += 1;

          myArray = findAllOpenTiles();
          rand = myArray[Math.floor(Math.random() * myArray.length)];
          goldArr.push(new Gold(rand.X, rand.Y, enemyIDtracker));
          goldIDtracker += 1;

          if((goalTile.X == numberOfTilesX_axis-1) && (goalTile.Y == numberOfTilesY_axis-1))
          {
            goalTile.X = 0;
            goalTile.Y = 0;
          }
         else if((goalTile.X == 0) && (goalTile.Y == 0))
          {
            goalTile.X = numberOfTilesX_axis-1;
            goalTile.Y = numberOfTilesY_axis-1;
          }
          document.getElementById("Points").innerText = "You have " + points + " points";
        }
      }

      function Tile(x,y)
      {
        this.X = x;
        this.Y = y;
      }

      //returns array of open tiles
      function findAllOpenTiles()
      {
        var tempOpenTiles = [];
        for(var x = 0; x < numberOfTilesX_axis; x++)
        {
            for(var y = 0; y < numberOfTilesY_axis; y++)
          {
            if(checkIfTileHasPieceOnIt(x,y))
            {
              //colorTile(x,y,"blue");
              //instead of coloring tiles push available tiles to an array, then randomly choose a tile to add a piece to.
              tempOpenTiles.push(new Tile(x,y));
            }
          }
        }
        return tempOpenTiles;
      }

      function checkIfTileHasPieceOnIt(x,y)
      {
        for(var i = 0; i < enemyArr.length; i++)
        {
          if(enemyArr[i].X === x && enemyArr[i].Y ===y)
            {
              return false
            }
        }

        for(var i = 0; i < goldArr.length; i++)
        {
          if(goldArr[i].X === x && goldArr[i].Y ===y)
            {
              return false
            }
        }

        //just do a for loop through all game pieces
        if(player.X === x && player.Y ===y)
        {
          return false
        }
        if(numberOfTilesX_axis-1 === x && numberOfTilesY_axis-1 ===y)
        {
          return false
        }
        if(0 === x && 0 ===y)
        {
          return false
        }
        //also check if it is other goalTile (make BOTH goal tiles off limit)
        else 
        {
          return true;
        }
      }

      function colorTile(x,y,color)
      {
        ctx.beginPath();
        ctx.lineWidth=2;
        ctx.strokeStyle="yellow";
        ctx.fillStyle = color;
        ctx.rect(tileToPixelCenter[x]-centerOfTileToSideOfTile,tileToPixelCenter[y]-centerOfTileToTopOfTile,centerOfTileToSideOfTile*2,centerOfTileToTopOfTile*2); 
        ctx.fill();
        ctx.stroke();
      }

      function checkIfPlayerTriesToMoveOntoEnemy()
      {
        for(var i = 0; i < enemyArr.length; i++)
        {
          if(player.X === enemyArr[i].X && player.Y === enemyArr[i].Y)
          {
            alert("you moved onto an enemy. You lose all points!");
            points = 0;
            document.getElementById("Points").innerText = "You have " + points + " points";
          }
        }
      }

      function checkIfPlayerTriesToMoveOntoGold()
      {
        for(var i = 0; i < goldArr.length; i++)
        {
          if(player.X === goldArr[i].X && player.Y === goldArr[i].Y)
          {
            gold += Math.floor(Math.random() * 20) + 1;
            document.getElementById("Gold").innerText = "You have " + gold + " gold";
            removeGoldFromArray(goldArr[i].ID)
          }
        }
      }

      function removeGoldFromArray(id)
      {
        var index = goldArr.map(function(g) { return g.ID; }).indexOf(id);
        if (index > -1) 
          {
            goldArr.splice(index, 1);
          }
      }

      function reDrawCanvas()
      {
        ctx.clearRect(0, 0, width, height);
        //draw board
        drawTileGrid();
        checkForGoal();
        drawGoalTile(goalTile.X,goalTile.Y);
        for(var i = 0; i < goldArr.length; i++)
        {
          goldArr[i].drawGold(goldArr[i].X,goldArr[i].Y);
        }
        //draw pieces: player and enemys
        drawPlayer(player.pixelX, player.pixelY);
        checkIfPlayerTriesToMoveOntoEnemy();

        // for(var i = 0; i < enemyArr.length; i++)
        // {
        //   enemyArr[i].moveEnemy();
        // }
        for(var i = 0; i < enemyArr.length; i++)
        {
          enemyArr[i].drawEnemy(enemyArr[i].pixelX,enemyArr[i].pixelY);
        }

      }
  
function animatePlayer()
{
      if(tileToPixelCenter[player.destX] < player.pixelX)
        {
          player.pixelX -= 5;
          reDrawCanvas();
        }
      if(tileToPixelCenter[player.destX] > player.pixelX)
        {
          player.pixelX += 5;
          reDrawCanvas();
        }
      if(tileToPixelCenter[player.destY] < player.pixelY)
        {
          player.pixelY -= 5;
          reDrawCanvas();
        }
      if(tileToPixelCenter[player.destY] > player.pixelY)
        {
          player.pixelY += 5;
          reDrawCanvas();
        }
  
      if(tileToPixelCenter[player.destX] !== player.pixelX || tileToPixelCenter[player.destY] !== player.pixelY)
        {
          requestAnimationFrame(animatePlayer);
        }
}

function animateEnemys(enemy)
{
  for(var i = 0; i < enemyArr.length; i++)
    {
      if(tileToPixelCenter[enemyArr[i].destX] < enemyArr[i].pixelX)
        {
          enemyArr[i].pixelX -= 5;
        }
      if(tileToPixelCenter[enemyArr[i].destX] > enemyArr[i].pixelX)
        {
          enemyArr[i].pixelX += 5;
        }
      if(tileToPixelCenter[enemyArr[i].destY] < enemyArr[i].pixelY)
        {
          enemyArr[i].pixelY -= 5;
        }
      if(tileToPixelCenter[enemyArr[i].destY] > enemyArr[i].pixelY)
        {
          enemyArr[i].pixelY += 5;
        }
      }
    
    reDrawCanvas();

    if(enemyArr.length > 0) //come up with a better check for when enemy finishes animations
    {
          if(tileToPixelCenter[enemyArr[0].destX] !== enemyArr[0].pixelX || tileToPixelCenter[enemyArr[0].destY] !== enemyArr[0].pixelY)
            {
              requestAnimationFrame(animateEnemys);
            }
    }
}

  drawTileGrid();
  drawGoalTile(goalTile.X,goalTile.Y);
  drawPlayer(tileToPixelCenter[player.X], tileToPixelCenter[player.Y]);

      document.addEventListener('keydown', function(event) {
        const key = event.key; // "ArrowRight", "ArrowLeft", "ArrowUp", or "ArrowDown"
        switch (key) {
        case "ArrowLeft":
            if(player.X < 1)
            {
              alert("out of bounds");
            }
            else
            {
              player.pixelX = tileToPixelCenter[player.X];
              player.X -= 1;
              player.destX -= 1;
              checkIfPlayerTriesToMoveOntoGold();
              animatePlayer();
                for(var i = 0; i < enemyArr.length; i++)
                {
                  enemyArr[i].moveEnemy();
                }
              animateEnemys();
            }
            break;
        case "ArrowUp":
            if(player.Y < 1)
            {
              alert("out of bounds");
            }
            else
            {
              player.pixelY = tileToPixelCenter[player.Y];
              player.Y -= 1;
              player.destY -= 1;
              checkIfPlayerTriesToMoveOntoGold();
              animatePlayer();
                for(var i = 0; i < enemyArr.length; i++)
                {
                  enemyArr[i].moveEnemy();
                }
              animateEnemys();
            }
            break;
        case "ArrowRight":
            if(player.X >= numberOfTilesX_axis-1)
            {
              alert("out of bounds");
            }
            else
            {
              player.pixelX = tileToPixelCenter[player.X];
              player.X += 1;
              player.destX += 1;
              checkIfPlayerTriesToMoveOntoGold();
              animatePlayer();
                for(var i = 0; i < enemyArr.length; i++)
                {
                  enemyArr[i].moveEnemy();
                }
              animateEnemys();
            }
            break;
        case "ArrowDown":            
            if(player.Y >= numberOfTilesY_axis-1)
            {
              alert("out of bounds");
            }
            else
            {
              player.pixelY = tileToPixelCenter[player.Y];
              player.Y += 1;
              player.destY += 1;
              checkIfPlayerTriesToMoveOntoGold();
              animatePlayer();
                for(var i = 0; i < enemyArr.length; i++)
                {
                  enemyArr[i].moveEnemy();
                }
              animateEnemys();
            }
            break;
        }
      });

//todo: prototype chain piece -> player/enemy/goal? player and enemy inherit prototype for radius property and drawing player and enemy

//todo: create a tile object for putting int open tiles array and for methods for coloring or methods like checking if a tile is open.

    //todo: use functional programming like filter instead of looping through arrays

    //todo: remove "check" functions from reDraw canvas funciton

    //todo: bind checkIfPlayerTries and removeGold removeEnemy functions as one
</script>

</html>